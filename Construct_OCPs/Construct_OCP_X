%% Make sure the correct models and scripts are in the path
% Define main properties
nx              = 4;		% Size of the state
nu              = 1;		% Size of input u
foh             = 0;		% First order hold reconstruction            
timestep = 0.1;				% Discretization
nSteps   = 20;				% N. Number of steps in OCP. Timehorizon = timestep*nSteps
uMax            = 0.85;		% input voltage is limited !When using dry friction compensation this needs to be reduced accordingly!

l_bar = 0.4;                % Unchanged through operation. Needs to be hardcoded

w= [0.02,0,1];              % Weighing vector for each component. 
							% w(1) --> input regularization weight
							% w(2) --> additional stabilization term
							% w(3) --> trajectory tracking weight

wQ = [1,0.3,0.05,0.05];		% Weighting of each component of trajectory tracking
							% wQ(1) --> x
							% wQ(2) --> theta
							% wQ(3) --> x_dot
							% wQ(4) --> theta_dot                               
% Construct solver Print supression increases performance significantly
ocp = casadi.Opti();
qpsol_options = struct;
qpsol_options.print_iter = false;
qpsol_options.print_info = false;
qpsol_options.print_lincomb = false;
qpsol_options.print_header= false;
s_opts = struct("qpsol", 'qrqp', "max_iter", 2000, 'qpsol_options',qpsol_options,'print_time',false,'print_header',false,'verbose',0,'print_status',false);
ocp.solver('sqpmethod',s_opts);   % SQP method only used to call QP. Standalone QP call requires strict problem construction and is not faster.
ocp.subject_to( )  

% Load parameters for trajectory 
load('Data\Scenario_3_trajectory.mat')

% The trajectory should only depend on the time t_p that changes every mpc
% increment. 
t_p = ocp.parameter(1,1);
x_ref = casadi.MX(2*nx,nSteps);
u_ref = casadi.MX(2*nu,nSteps);
custom_mod = @(a,b) a-b*floor(a/(b));
% Defines reference based on t_p and the evaluation of a sinusoidal
% reference trajcetory 
for i = 1:nSteps
x_ref(:,i) = evaluateSines(sine_params_trajectory,(t_p+timestep*(i-1)));
u_ref(:,i) = evaluateSines(sine_params_trajectory_u,(t_p+timestep*(i-1)));
end
%% split subsystems xX and xY
x_X_ref = x_ref([1,3,5,7],:);
u_X_ref = u_ref([1],:);
x_Y_ref = x_ref([2,4,6,8],:);
u_Y_ref = u_ref([2],:);
%%
% Create ode with integrator This ODE is in form x_dot = Ax + Bu 
[A_noL B_noL] = linearize_system_old([0,0,l_bar,0,0,0,0,0,0,0]',[0,0,0]');
% transform into x_plut = Ax + Bu
sys_cont = ss(A_noL, B_noL,zeros(2,size(A_noL,1)),zeros(2, size(B_noL, 2)));
%
sys_disc = c2d(sys_cont, timestep, 'zoh');
A_d = sys_disc.A;
B_d = sys_disc.B;
C_d = sys_disc.C;
D_d = sys_disc.D;
% Construct 2 decoupled systems
indices1 = [1, 2, 3, 4];
indices2 = [5, 6, 7, 8];

AX = A_d(indices1, indices1);
AY = A_d(indices2, indices2);

BX = B_d(indices1, 1);
BY = B_d(indices2, 2);
ode_fun_X = @(x,u) [AX*x + BX*u];
ode_fun_Y = @(x,u) [AY*x + BY*u];
%% % initial state as parameter
x0_p = ocp.parameter(nx,1);

% control input as decision variable
u_dec = ocp.variable(nu,  nSteps+foh);
u = u_dec;

% apply dynamic constraint in full discretization fashion 
idx = 1;
h_integ = casadi.MX(nx, nSteps-1);
x_dec = ocp.variable(nx,nSteps-1);
x=[x0_p, x_dec]; 
for Node = 1:nSteps-1
h_integ(:,(Node)) = x(:,Node+1)-ode_fun_X(x(:,Node), u(:, Node));
end
h_zero = h_integ(:) == 0;
ocp.subject_to( h_zero )


%%
% Define all components of cost function
ref_tracking_error = 0;
ref_tracking_u_error = 0;
decay = @(n) 1-0.04*n;                   % could be used to weight steps
Q_w = wQ.*eye(4);
R_w = eye(1);
% Reference tracking error 
ref_tracking_error = wQ(1)*sum(sum((x(1,:)-x_X_ref(1,:)).^2));
ref_tracking_error =ref_tracking_error + wQ(2)*sum(sum((x(2,:)-x_X_ref(2,:)).^2));
ref_tracking_error =ref_tracking_error + wQ(3)*sum(sum((x(3,:)-x_X_ref(3,:)).^2));
ref_tracking_error =ref_tracking_error + wQ(4)*sum(sum((x(4,:)-x_X_ref(4,:)).^2));
% Reference u error 
ref_tracking_u_error =sum(sum((u(1,:)-u_X_ref(1,:)).^2));

% Additional cost to keep the movement of the pendulum relativ to the cart
% minimal (penalize any angle/angle derivative)
cost_stabilize =  sum(sum(x([2,4],:).^2));

cost =   w(1)*ref_tracking_u_error + w(2)*cost_stabilize   + w(3)*ref_tracking_error;
ocp.minimize(cost);

% Apply admissble u constraint
ocp.subject_to(-uMax <= u <= uMax);

% Apply admissible set constraints
lower_bound = [0, -pi/5, -0.5, - 2*pi];
upper_bound = [0.5,  pi/5, 0.5,  2*pi];
ocp.subject_to(lower_bound'<= x < upper_bound');
%% construction of casadi mex function with warmstart 
% Function f takes objects from casadi as input. in the first brackets []
% are the inpus. Here for example you could only use the parameters
% u_p,x0_p,x_ref_p but you can also hand over the decision variables so the
% solver can warm start!
% as output you can choose whatever you want as long as there is a varibale
% (as a casadi object) 
f = ocp.to_function('f',[primitives(x0_p),{x_dec, u, t_p, ocp.lam_g}],{(full(u(:,1:end))), [(full(x(:,1))) (full(x_dec(:,:)))],(full(ocp.lam_g)),full(x_X_ref),full(u_X_ref)});
% Save to file
file_name = 'f.casadi';
f.save(file_name);
%% Compile MEx funciton 
import casadi.*
lib_path = GlobalOptions.getCasadiPath();
inc_path = GlobalOptions.getCasadiIncludePath();
mex('-v',['-I' inc_path],['-L' lib_path],'-lcasadi', 'casadi_fun.c')
